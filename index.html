<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tic Tac Toe — Random Pattern Password Generator</title>
  <style>
    :root{--cell-size:100px;--gap:8px}
    body{font-family:Inter,Segoe UI,Arial;margin:20px;background:#0f172a;color:#e6eef8}
    .wrap{max-width:520px;margin:0 auto}
    .board{position:relative;width:calc(var(--cell-size)*3 + var(--gap)*2);height:calc(var(--cell-size)*3 + var(--gap)*2);margin:12px auto;display:grid;grid-template-columns:repeat(3,var(--cell-size));grid-template-rows:repeat(3,var(--cell-size));gap:var(--gap);}
    .cell{display:flex;align-items:center;justify-content:center;background:#071027;border-radius:12px;font-size:36px;cursor:text;user-select:none;border:2px solid rgba(255,255,255,0.04);transition:box-shadow .18s,transform .12s}
    .cell:focus{box-shadow:0 8px 24px rgba(34,197,94,0.08);transform:translateY(-2px)}
    .cell[contenteditable="true"]{outline:none}
    .controls{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin-top:10px}
    button,input,select{padding:8px 12px;border-radius:8px;border:0;background:#0b2540;color:#dff;cursor:pointer}
    input[type="number"]{width:86px}
    .info{margin-top:12px;text-align:center}
    svg.overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    .password{margin-top:10px;background:#071127;padding:10px;border-radius:8px;text-align:center;font-family:monospace}
    .small{font-size:13px;color:#9fb6d8}
    .cell.visited{box-shadow:0 6px 18px rgba(0,0,0,0.6) inset;border-color:#2dd4bf}
    .cell.revisit{box-shadow:0 6px 18px rgba(0,0,0,0.6) inset;border-color:#f59e0b}
  </style>
</head>
<body>
  <div class="wrap">
    <h2>3×3 ASCII Tic-Tac-Toe — Random Pattern</h2>
    <div class="small">Type one ASCII char per cell (only the first char is used). Use Start to randomize and generate a password path.</div>

    <div class="board" id="board">
      <svg class="overlay" id="overlay"></svg>
    </div>

    <div class="controls">
      <button id="randomStart">Randomize & Start</button>
      <button id="moveCorner">Jump to Random Corner (animate)</button>
      <button id="startPattern">Start Pattern</button>
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>

      <label class="small">Max password chars: <input id="maxLen" type="number" min="1" value="9"></label>
      <label class="small"><input id="startCornerChk" type="checkbox"> Start at random corner</label>
      <label class="small">Speed (ms step): <input id="speed" type="number" min="50" value="400"></label>
    </div>

    <div class="info">
      <div class="password">Generated password: <strong id="password">(none)</strong></div>
      <div class="small">Arrows show movement direction. Lines connect centers of visited cells. The path stops when all cells are taken or max chars reached.</div>
    </div>
  </div>

<script>
const boardEl = document.getElementById('board');
const overlay = document.getElementById('overlay');
const maxLenInput = document.getElementById('maxLen');
const speedInput = document.getElementById('speed');
const passwordEl = document.getElementById('password');
let cells = [];
let visitedOrder = [];
let running = false;
let paused = false;
let animTimer = null;
const lineVisits = new Map();

function createBoard(){
  boardEl.querySelectorAll('.cell').forEach(n=>n.remove());
  overlay.innerHTML='';
  cells = [];
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      const div=document.createElement('div');
      div.className='cell';
      div.contentEditable='true';
      div.dataset.r=r; div.dataset.c=c;
      div.innerText='';
      div.addEventListener('input',()=>{
        if(div.innerText.length>1) div.innerText=div.innerText[0];
      });
      boardEl.appendChild(div);
      cells.push({el:div,r,c,char:'',x:0,y:0});
    }
  }
  requestAnimationFrame(()=>{
    cells.forEach(cell=>{
      const rect=cell.el.getBoundingClientRect();
      const parentRect=boardEl.getBoundingClientRect();
      cell.x=rect.left-parentRect.left+rect.width/2;
      cell.y=rect.top-parentRect.top+rect.height/2;
    });
  });
}
createBoard();

function resetState(){
  visitedOrder=[];
  running=false;
  paused=false;
  clearTimeout(animTimer);
  overlay.innerHTML='';
  passwordEl.innerText='(none)';
  cells.forEach(c=>c.el.classList.remove('visited','revisit'));
  lineVisits.clear();
}
function idx(r,c){return r*3+c}
function inBounds(r,c){return r>=0&&r<3&&c>=0&&c<3}
function segmentKey(r1,c1,r2,c2){const a=r1*3+c1,b=r2*3+c2;return a<b?`${a}-${b}`:`${b}-${a}`}

function drawArrow(x1,y1,x2,y2){
  const svgns='http://www.w3.org/2000/svg';
  const k=segmentKey(Math.round(y1),Math.round(x1),Math.round(y2),Math.round(x2));
  const count=(lineVisits.get(k)||0)+1;
  lineVisits.set(k,count);
  const colors=['#58f','#f59e0b','#fb7185'];
  const color=count<=colors.length?colors[count-1]:colors[colors.length-1];
  const line=document.createElementNS(svgns,'line');
  line.setAttribute('x1',x1);line.setAttribute('y1',y1);line.setAttribute('x2',x2);line.setAttribute('y2',y2);
  line.setAttribute('stroke',color);line.setAttribute('stroke-width','6');line.setAttribute('stroke-linecap','round');
  overlay.appendChild(line);
  const angle=Math.atan2(y2-y1,x2-x1);
  const ax=x2-Math.cos(angle)*18,ay=y2-Math.sin(angle)*18;
  const p1=`${x2},${y2}`,p2=`${ax-Math.sin(angle)*8},${ay+Math.cos(angle)*8}`,p3=`${ax+Math.sin(angle)*8},${ay-Math.cos(angle)*8}`;
  const poly=document.createElementNS(svgns,'polygon');
  poly.setAttribute('points',`${p1} ${p2} ${p3}`);poly.setAttribute('fill',color);
  overlay.appendChild(poly);
}

function randomCell(){const i=Math.floor(Math.random()*9);return{r:Math.floor(i/3),c:i%3}}
function randomCorner(){const corners=[{r:0,c:0},{r:0,c:2},{r:2,c:0},{r:2,c:2}];return corners[Math.floor(Math.random()*4)];}

function visit(r,c){
  const i=idx(r,c);const cell=cells[i];
  const ch=cell.el.innerText||' ';cell.char=ch[0]||' ';
  visitedOrder.push({r,c,char:cell.char,x:cell.x,y:cell.y});
  const occur=visitedOrder.filter(v=>v.r===r&&v.c===c).length;
  if(occur>1) cell.el.classList.add('revisit'); else cell.el.classList.add('visited');
}

function randomDir(){
  const dirs=[
    {r:0,c:1},{r:0,c:-1},{r:1,c:0},{r:-1,c:0},
    {r:1,c:1},{r:1,c:-1},{r:-1,c:1},{r:-1,c:-1}
  ];
  return dirs[Math.floor(Math.random()*dirs.length)];
}

async function runPattern(opts={startAtCorner:false}){
  resetState();
  running=true;paused=false;
  const maxLen=Math.max(1,Number(maxLenInput.value)||9);
  const speed=Math.max(30,Number(speedInput.value)||300);
  cells.forEach(cell=>{
    const rect=cell.el.getBoundingClientRect();
    const parentRect=boardEl.getBoundingClientRect();
    cell.x=rect.left-parentRect.left+rect.width/2;
    cell.y=rect.top-parentRect.top+rect.height/2;
  });
  let current=opts.startAtCorner?randomCorner():randomCell();
  visit(current.r,current.c);
  let last=visitedOrder[visitedOrder.length-1];

  while(running && visitedOrder.length<maxLen && visitedOrder.length<9){
    while(paused) await new Promise(r=>setTimeout(r,100));
    const dir=randomDir();
    let cr=current.r+dir.r,cc=current.c+dir.c;
    let moved=false;let prev={r:current.r,c:current.c};
    while(inBounds(cr,cc) && visitedOrder.length<maxLen && visitedOrder.length<9){
      const from=cells[idx(prev.r,prev.c)],to=cells[idx(cr,cc)];
      drawArrow(from.x,from.y,to.x,to.y);
      visit(cr,cc);moved=true;
      prev={r:cr,c:cc};current={r:cr,c:cc};
      if(visitedOrder.length>=maxLen) break;
      await new Promise(r=>setTimeout(r,speed));
      cr+=dir.r;cc+=dir.c;
    }
    if(!moved) await new Promise(r=>setTimeout(r,speed/2));
  }

  const pass=visitedOrder.map(v=>v.char||' ').join('').slice(0,Number(maxLen));
  passwordEl.innerText=pass||'(none)';
  running=false;
}

document.getElementById('randomStart').addEventListener('click',()=>{
  for(const c of cells){
    const ch=String.fromCharCode(33+Math.floor(Math.random()*94));
    c.el.innerText=ch;
  }
  const startCorner=document.getElementById('startCornerChk').checked;
  runPattern({startAtCorner:startCorner,jumpToCorner:false});
});

document.getElementById('moveCorner').addEventListener('click',async()=>{
  if(running) return;
  cells.forEach(cell=>{
    const rect=cell.el.getBoundingClientRect();
    const parentRect=boardEl.getBoundingClientRect();
    cell.x=rect.left-parentRect.left+rect.width/2;
    cell.y=rect.top-parentRect.top+rect.height/2;
  });
  resetState();
  running=true;
  const start=randomCell();
  visit(start.r,start.c);
  await new Promise(r=>setTimeout(r,200));
  await runPattern({startAtCorner:false,jumpToCorner:true});
  running=false;
});

let patternPromise=null;
document.getElementById('startPattern').addEventListener('click',()=>{
  if(running) return;
  const startCorner=document.getElementById('startCornerChk').checked;
  patternPromise=runPattern({startAtCorner:startCorner,jumpToCorner:false});
});

document.getElementById('pauseBtn').addEventListener('click',()=>{
  paused=!paused;
  document.getElementById('pauseBtn').innerText=paused?'Resume':'Pause';
});
document.getElementById('resetBtn').addEventListener('click',()=>resetState());
boardEl.addEventListener('focusout',e=>{
  if(e.target.classList && e.target.classList.contains('cell')){
    if(e.target.innerText.length>1) e.target.innerText=e.target.innerText[0];
  }
});
window.addEventListener('resize',()=>{
  cells.forEach(cell=>{
    const rect=cell.el.getBoundingClientRect();
    const parentRect=boardEl.getBoundingClientRect();
    cell.x=rect.left-parentRect.left+rect.width/2;
    cell.y=rect.top-parentRect.top+rect.height/2;
  });
});
</script>
</body>
</html>
